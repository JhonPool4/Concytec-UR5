#!/usr/bin/env python

import rospy 							# ROS with Python
from sensor_msgs.msg import JointState 	# To send angular position to robot
from markers import *					# To show a market ball 
from funciones import *					# Forward Kinematics, Inverse Kinematics and Dynamic
from roslib import packages				# Library with ROS packagues
import rbdl								# Library to compute matrix H and B of robot
pi = np.pi

# Create a nodo: control_SMD
rospy.init_node("control_SMD")

# Public in topic /joint_states			
pub = rospy.Publisher('joint_states', JointState, queue_size=1000)

# Show a ball marker for current and desired position of robot' end-effector
bmarker_actual  = BallMarker(color['RED'])
bmarker_deseado = BallMarker(color['GREEN'])


# File with current and desired position
fqact = open("/home/utec/Escritorio/Simulaciones_Sliding/UR5_data/qactual.dat", "w")
fqdes = open("/home/utec/Escritorio/Simulaciones_Sliding/UR5_data/qdeseado.dat", "w")
fxact = open("/home/utec/Escritorio/Simulaciones_Sliding/UR5_data/xactual.dat", "w")
fxdes = open("/home/utec/Escritorio/Simulaciones_Sliding/UR5_data/xdeseado.dat", "w")

# ========================================================
# 			Send angular position data to UR5
# ========================================================

# Configuracion articular inicial (en radianes)
q = np.array([pi/8, -pi/4, pi/8, pi/2, 0.0, 0.0])
# Velocidad inicial
dq = np.array([0., 0., 0., 0., 0., 0.])
# Configuracion articular deseada
qdes 	= np.array([pi/8, -pi/4, pi/8, pi/2, 0.0, 0.0])
dqdes 	= np.array([0.0, 0.0, 0.0, 0.0, 0.0, 0.0])
ddqdes 	= np.array([0.0, 0.0, 0.0, 0.0, 0.0, 0.0])
# Desired position related with desired joint configuration
xdes = fkine_ur5(qdes)[0:3,3]

# Joints name of UR5 robot
jnames = ['shoulder_pan_joint', 'shoulder_lift_joint', 'elbow_joint','wrist_1_joint', 'wrist_2_joint', 'wrist_3_joint']

# Object(messague) type JointState
jstate = JointState()

# Messague
jstate.header.stamp = rospy.Time.now() 	# Current time
jstate.name 		= jnames					# joints name
jstate.position 	= q

# Send joints position
pub.publish(jstate)

# =============================================================
# 					Robot Dynamics
# =============================================================

# Modelo RBDL
modelo = rbdl.loadModel('/home/utec/ros_ws/src/ur5/ur5_description/urdf/ur5_joint_limited_robot.urdf')
ndof   = modelo.q_size     # Degrees of Freedom

# Communication frecuency (Hz)
freq 	= 100
dt 		= 1.0/freq
rate 	= rospy.Rate(freq)

# Arrays numpy
g     = np.zeros(ndof)          # Gravity
b     = np.zeros(ndof)          # Nonlinear effects
b_hat = np.zeros(ndof) 			# Best estimation of b matrix
M     = np.zeros([ndof, ndof])  # Inercial matrix
M_hat = np.zeros([ndof, ndof])  # Best estimation of H matrix
zeros = np.zeros(ndof)			# Zeros matrix
s     = np.zeros(ndof)			# surface 6x1

# Create a object Robot with dynamics of UR5 robot
UR5_robot = Robot(q, dq, ndof, dt)

# =============================================================
# 					SMD Parameters
# =============================================================

Lambda  = 30*np.identity(6)
n 		= 0.1*np.ones(6)
Fi 		= 0.1/Lambda[0,0]
alpha 	= 0.05 				# percentage of uncertainty

# =============================================================
# 				Simulation UR5 with SMD
# =============================================================

# Inicizlize time
t = 0.0


while not rospy.is_shutdown():

	# Desired trajectory

	xdes 		= np.array([  0.4,	0.0, 0.0 ])
	dxdes 		= np.array([  0.0, 	0.0, 0.0 ])
	ddxdes 		= np.array([  0.0,	0.0, 0.0 ])

	qdes 		= ikine_ur5(xdes,q)
	dqdes 		= np.dot(pseudoInversa(jacobian_ur5(q)),xdes)

	# Read position and velocity angular of UR5 joints
	q  		= UR5_robot.read_joint_positions()
	dq 		= UR5_robot.read_joint_velocities()
	M_hat 	= UR5_robot.get_M()
	b_hat 	= UR5_robot.get_b()

	# Current Position of UR5 end-effector
	x 		= fkine_ur5(q)[0:3,3]

	# Current time (This is necessary for a correct simulation in ROS)
	jstate.header.stamp = rospy.Time.now()

	#===================================
	#			Control Law
	#===================================
	e 		= q 		- 	qdes 				# Position error
	de 		= dq 		- 	dqdes 			    # Velocity error
	s 		= de 		+ 	np.dot(Lambda,e) 	# Surface

	k 		= n 		+ 	abs( alpha*b_hat + np.dot(M_hat, (ddqdes-np.dot(Lambda,de))) +
							0.5*(1-alpha)*np.dot(M_hat, (de + np.dot(Lambda,e))))

	u 		= b_hat + np.dot(M_hat,ddqdes) - np.dot(M_hat, np.dot(Lambda,de)) - k*np.sign(s)	# Effort control

	# Simulation of robot - Use effort control to compute dqq, dq and q
	UR5_robot.send_command(u)

	# Publish message
	jstate.position = q
	pub.publish(jstate)
	bmarker_deseado.xyz(xdes)
	bmarker_actual.xyz(x)
	t = t+dt
	# Esperar hasta la siguiente  iteracion
	rate.sleep()

fqact.close()
fqdes.close()
fxact.close()
fxdes.close()