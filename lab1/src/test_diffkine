#!/usr/bin/env python

import rospy 							# ROS with Python
from sensor_msgs.msg import JointState 	# To send angular position to robot
from markers import *					# To show a market ball 
from funciones import *					# Forward Kinematics, Inverse Kinematics and Dynamic
from roslib import packages				# Library with ROS packagues
import rbdl								# Library to compute matrix H and B of robot

# Create nodo
rospy.init_node("test_diff_control")

# Public in topic /joint_states
pub = rospy.Publisher("/joint_states", JointState, queue_size=1000)

# Show a ball marker for current and desired position of robot' end-effector
bmarker_actual  = BallMarker(color['RED'])
bmarker_deseado = BallMarker(color['GREEN'])

# ========================================================
# 			Parameters of Controller
# ========================================================
# Numpy matrix
q 			= 	np.zeros(6)
dq 			= 	np.zeros(6)
qdes 		= 	np.zeros(6)
dqdes 		= 	np.zeros(6)
x 			= 	np.zeros(3)
xdes 		= 	np.zeros(3)
e 			= 	np.zeros(3)
de 			= 	np.zeros(3)
k 			= 	10

# Initial joint configuration
q 		= 	[0.0, 0, 0, 0.0, 0.0, 0.0]
# Initial position
T 		= 	fkine_ur5(q)
x 		= 	T[0:3,3]
Q 		= 	rot2quat(T[0:3,0:3])

# Desired position
xdes 	= 	np.array([0.4, 0.4, 0.4])
Rdes 	= 	np.array([[0,1,0],[1,0,0],[0,0,-1]])
Qdes 	= 	rot2quat(Rdes)

# ========================================================
# 			Parameters of UR5 robot
# ========================================================
# Communication frecuency (Hz)
freq 	= 100
dt 		= 1.0/freq 			# 10 ms
rate 	= rospy.Rate(freq)
# Joints name of UR5 robot
jnames = ['shoulder_pan_joint', 'shoulder_lift_joint', 'elbow_joint','wrist_1_joint', 'wrist_2_joint', 'wrist_3_joint']

# Object(messague) type JointState
jstate = JointState()

# Messague
jstate.header.stamp = rospy.Time.now() 	# Current time
jstate.name 		= jnames					# joints name
jstate.position 	= q

# Send joints position
pub.publish(jstate)
bmarker_deseado.xyz(xdes)
bmarker_actual.xyz(x)

# =============================================================
# 				Simulation UR5 with SMD
# =============================================================

# Inicizlize time
t = 0.0

while not rospy.is_shutdown():

	# Current pose of robot
	T 		= 	fkine_ur5(q)
	x 		= 	T[0:3,3]
	Q 		= 	rot2quat(T[0:3,0:3])
	# Compute position error
	ep 		= 	x - xdes
	e0 		= 	quatError(Qdes, Q)
	e 		= 	np.concatenate((ep, e0), axis = 0)
	de 		= 	-k*e
	#J 		= 	np.expand_dims(jacobian_pose_ur5(q), axis = 1)
	Jinv 	= 	pseudoInversa(jacobian_pose_ur5(q)) # np.linalg.pinv(jacobian_ur5(q))

	dq 		= 	np.dot(Jinv,de)
	q 		= 	q + dt*dq

	# Current time (This is necessary for a correct simulation in ROS)
	jstate.header.stamp = rospy.Time.now()
	# Publish message
	jstate.position = q
	pub.publish(jstate)
	bmarker_deseado.xyz(xdes)
	bmarker_actual.xyz(x)
	t = t+dt
	print(t)
	# Esperar hasta la siguiente  iteracion
	rate.sleep()


