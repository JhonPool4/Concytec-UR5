#!/usr/bin/env python

# ============================================================
# 	Authors :   Jhon Charaja y Samir Munoz
# 	Info	:	Articular adaptive PD controller for UR5 robot
# ============================================================

# ============================
# 			Libraries
# ============================ 
import rospy 							# ROS with Python
import os 								# Manipulate path names
import pandas as pd 					# Save data
from sensor_msgs.msg import JointState 	# To send angular position to robot
from markers import *					# To show a market ball 
from functions import *					# Kinematics, dynamics and trajectories
from roslib import packages				# Library with ROS packages
import rbdl								# Library to compute dynamic matrix H and B of robot
pi = np.pi 								# Define "pi"
from datetime import datetime


# ===============================
# 		Configuration of node
# ===============================
# Create a nodo: PID_controller
rospy.init_node("PDi_controller_ur5")
cwd = os.path.dirname(os.path.realpath(__file__))

# Public in topic /joint_states	to send joint data		
pub = rospy.Publisher('joint_states', JointState, queue_size=1000)

# ===============================
# 		Line and Ball Marker
# ===============================
# Show a ball marker for current and desired position of robot' end-effector
bmarker_des 	= BallMarker(color['RED'])
bmarker_act  	= BallMarker(color['YELLOW'])

# =============================================================
# 					Robot Dynamics
# =============================================================
modelo = rbdl.loadModel(os.path.join(cwd,'../../ur5_description/urdf/ur5_joint_limited_robot.urdf'))
ndof   = modelo.q_size     # Degrees of freedom

# Generar objeto/espacio del vector b y M
b = np.zeros(ndof)
M = np.zeros((ndof,ndof))

M_x = np.zeros((7,7))
b_x = np.zeros(7)

# Joints name of UR5 robot
jnames = ['shoulder_pan_joint', 'shoulder_lift_joint', 'elbow_joint','wrist_1_joint', 'wrist_2_joint', 'wrist_3_joint']

# Object(messague) type JointState
jstate = JointState()

# Loop rate (in Hz)
f       = 100 				# [Hz]
rate 	= rospy.Rate(f)		# [Hz]
dt 		= 1e-2				# 100 ms

# =============================================================
# 				Initial configuration
# =============================================================
#  Home joint configuration of ur5 robot (radians)
q 		= np.array([0.22555947, -2.16092376, -2.13975583, -0.41997402,  1.53827725, -1.35006513]) # center 	[0.5 +0.0 0.0]
#q 		= np.array([0.02387449, -2.17330664, -2.11274865, -0.42801517,  1.53728324, -1.55185632]) # right 	[0.5 -0.1 0.0] t = 0.0
#q 		= np.array([0.18751981, -2.28693212, -1.84068068, -0.59154513,  1.53793921, -1.38812797]) # up		[0.6 +0.0 0.0]
#q 		= np.array([0.4182522 , -2.17178325, -2.11005823, -0.44335183,  1.53978351, -1.15730822]) # left  	[0.5 +0.1 0.0]
#q 		= np.array([0.28333472, -2.05939084, -2.41975261, -0.24162777,  1.53830479, -1.29228808]) # down 	[0.4 +0.0 0.0]
dq 			= np.zeros(ndof)
ddq 		= np.zeros(ndof)

# Desired angular position, velocity and acceleration
q_des 	 = np.zeros(ndof)
dq_des   = np.zeros(ndof) 
ddq_des  = np.zeros(ndof) 
dddq_des = np.zeros(ndof)

# Desired cartesian position and velocity
x_des 	 = np.array([0.5,   -0.1,  0.0, 0.01676998,  0.99985616,  0.00251062,  0.00 ])
dx_des 	 = np.zeros(7)
ddx_des  = np.zeros(7)
dddx_des = np.zeros(7)

# Measured angular position, velocity and acceleration
x_act 	 = np.zeros(7)
dx_act 	 = np.zeros(7)
ddx_act  = np.zeros(7)
dddx_act = np.zeros(7)

# Past velocity and acceleration
dx_act_p  = np.zeros(7)
ddx_act_p = np.zeros(7)

# Error angular position, velocity and acceleration
x_e    = np.zeros(7)
dx_e   = np.zeros(7)
ddx_e  = np.zeros(7)
dddx_e = np.zeros(7)

# s variable
s  = np.zeros(7)
ds = np.zeros(7)

# control signal
u = np.zeros(6)
F = np.zeros(7)

# Create a object Robot with dynamics of UR5 robot (code in functions.py)
UR5_robot = Robot(q, dq, ndof, dt)

# ================================
# 			PD controller
# ================================
alpha = 1*dt*np.array([1, 1, 1, 0.001, 0.001, 0.001, 0.001])

KP = 100*np.diag(np.array([1, 1, 1, 0.001, 0.001, 0.001, 0.001])) # Proportional matrix
KD = 2*np.sqrt(KP) # Damping matriz

dJ_kp = np.zeros(7)
dJ_kd = np.zeros(7)

# ================================
# 		Save data
# ================================
origin 	= './Data/PDi'
suffix 	= 'circular_traj'
folder = os.path.join(cwd, origin, suffix)

column_names = [
	'x', 'y', 'z', 'w', 'ex', 'ey', 'ez',
	'dx', 'dy', 'dz', 'dw', 'dex', 'dey', 'dez',	
	'ddx', 'ddy', 'ddz', 'ddw', 'ddex', 'ddey', 'ddez',
	'dddx', 'dddy', 'dddz', 'dddw', 'dddex', 'dddey', 'dddez',
	'x_des', 'y_des', 'z_des', 'w_des', 'ex_des', 'ey_des', 'ez_des',
	'dx_des', 'dy_des', 'dz_des', 'dw_des', 'dex_des', 'dey_des', 'dez_des',
	'ddx_des', 'ddy_des', 'ddz_des', 'ddw_des', 'ddex_des', 'ddey_des', 'ddez_des',
	'dddx_des', 'dddy_des', 'dddz_des', 'dddw_des', 'dddex_des', 'dddey_des', 'dddez_des',
	'e_x', 'e_y', 'e_z', 'e_w', 'e_ex', 'e_ey', 'e_ez',
	'de_x', 'de_y', 'de_z', 'de_w', 'de_ex', 'de_ey', 'de_ez',
	'dde_x', 'dde_y', 'dde_z', 'dde_w', 'dde_ex', 'dde_ey', 'dde_ez',
	'ddde_x', 'ddde_y', 'ddde_z', 'ddde_w', 'ddde_ex', 'ddde_ey', 'ddde_ez',	
	'kp1', 'kp2', 'kp3', 'kp4', 'kp5', 'kp6', 'kp7',
	'dkp1', 'dkp2', 'dkp3', 'dkp4', 'dkp5', 'dkp6', 'dkp7',
	'dkJp1', 'dJkp2', 'dJkp3', 'dJkp4', 'dJkp5', 'dJkp6', 'dJkp7',	
	'kd1', 'kd2', 'kd3', 'kd4', 'kd5', 'kd6', 'kd7',
	'dkd1', 'dkd2', 'dkd3', 'dkd4', 'dkd5', 'dkd6', 'dkd7',
	'dJkd1', 'dJkd2', 'dJkd3', 'dJkd4', 'dJkd5', 'dJkd6', 'dJkd7',	
	'u1', 'u2', 'u3', 'u4', 'u5', 'u6',
	's1', 's2', 's3', 's4', 's5', 's6', 's7',
	'ds1', 'ds2', 'ds3', 'ds4', 'ds5', 'ds6', 'ds7',	
	'J1', 'J2', 'J3', 'J4', 'J5', 'J6', 'J7'
	]

df = pd.DataFrame(columns=column_names)

# Filename
now = datetime.now()
now = now.strftime("%d-%m-%Y_%H-%M-%S")
fn = now
fn = "cartesian_Kp_100_alpha_10"

# Creates folder if it does not exist
if not os.path.exists(folder):
	os.makedirs(folder)

path = os.path.join(folder, fn)
df.to_csv(path, index=False)

# ================================
# 		Dynamic simulation
# ================================
t = 0.0
Jp = np.zeros([7,6])

while not rospy.is_shutdown():
	# desired values (cartesian space)
	x_des[0:3], dx_des[0:3], ddx_des[0:3], dddx_des[0:3] = circular_trayectory_generator(t)

	# Jacobian	
	J = jacobian_pose_ur5(q)
	dJ = (J-Jp)/dt
	J_inv = np.linalg.pinv(J)
	Jp = copy(J)

	# Current position and velocity of UR5 end-effector
	x_act[0:7]  = get_current_pose(q)
	dx_act[0:7] = get_current_dpose(J, dq)

	# Estimation of current acceleration and jerk of UR5 end-effector 
	ddx_act     = ddx_des + s 
	dddx_act    = dddx_des + ds  

	# Error in position, velocity and acceleration 
	x_e[0:7]   = compute_error_pose(x_des, x_act)
	dx_e[0:7]  = compute_error_dpose(dx_des, dx_act)
	ddx_e[0:7] = compute_error_ddpose(ddx_des, ddx_act)
	dddx_e[0:7]= compute_error_dddpose(dddx_des, dddx_act)
	

	# First derivative of Kp and Kd
	dkp = -np.multiply(alpha, dJ_kp)/dt
	dkd = -np.multiply(alpha, dJ_kd)/dt

	# s and ds
	s   = KP.dot(x_e)  + KD.dot(dx_e) 
	ds  = np.multiply(dkp,x_e) + KP.dot(dx_e) + np.multiply(dkd,dx_e) + KD.dot(ddx_e)	

	# Cost Function
	gamma = 0.999 # Modificar 
	cost = gamma*0.5*np.multiply(s,s) + (1-gamma)*0.5*np.multiply(ds,ds)

	# Gradient descent

	dJ_kp = gamma * np.multiply(s,x_e)    +  (1-gamma) * np.multiply(ds, dx_e)
	dJ_kd = gamma * np.multiply(s,dx_e)   +  (1-gamma) * np.multiply(ds, ddx_e)

	# New values of Kp, Kd
	KP = KP - alpha*np.diag(dJ_kp)
	KD = KD - alpha*np.diag(dJ_kd)

	# Get inertia matrix (M) and nonlinear effects vector (b)
	rbdl.NonlinearEffects(modelo, q, dq, b)
	rbdl.CompositeRigidBodyAlgorithm(modelo, q, M)

	# Inertia matrix on operational space
	b_x = F - np.dot(M_x, ddx_act)
	M_x = np.dot(np.dot(J_inv.transpose(), M), J_inv) # Mx = Jinv_t * M * J_inv
	#b_x = np.dot(J_inv.transpose(), b) - np.dot(np.dot(M_x, dJ), dq)	 
	

	# PD + Feedback linearization
	F = M_x.dot(ddx_des + s ) + b_x
	u = np.dot( J.transpose() , F )	

	# Send control signal
	u = saturador_effort_control_UR5(u)
	UR5_robot.send_command(u)

	# Read angular position and velocity of UR5 joints
	q  = UR5_robot.read_joint_positions()
	dq = UR5_robot.read_joint_velocities()

	# Publish message
	jstate.header.stamp = rospy.Time.now()
	jstate.name 		= jnames			# Joints position name
	jstate.position 	= q 				# Joints position
	jstate.velocity 	= dq 				# Joints velocity
	pub.publish(jstate)		

	# Time
	t = t + dt

	# Ball marker
	bmarker_des.xyz(x_des[0:3])	# Red
	bmarker_act.xyz(x_act[0:3])	# Yellow

	# Fill empty info. Temporary
	kp = np.diag(KP)
	kd = np.diag(KD)

	#print("t: ", t)
	print("KP: ", kp[0:3])
	print("KD: ", kd[0:3])
	print("C:  ", cost[0:3])
	print("e: ", gamma * np.multiply(s,x_e)[0:3])
	print("J: ", (1-gamma)*0.5*np.multiply(ds,ds)[0:3])
	print("\n")
	#print("xi: ", ddx_e[0])
	#print("tau: ", u)

	if (t>=0.0):
		# Append data
		row = tl(x_act)+tl(dx_act)+tl(ddx_act)+tl(dddx_act)+tl(x_des)+tl(dx_des)+tl(ddx_des)+tl(dddx_des)+tl(x_e)+tl(dx_e)+tl(ddx_e)+tl(dddx_e)+tl(kp)+tl(dkp)+tl(dJ_kp)+tl(kd)+tl(dkd)+tl(dJ_kd)+tl(u)+tl(s)+tl(ds)+tl(cost)

		row = tl(np.expand_dims(np.array(row), axis = 1))

		# Fix for redimensionality
		df_row = pd.DataFrame.from_dict(dict(zip(column_names, row)))

		df.append(df_row, sort = False).to_csv(path, index=False, mode = 'a', header=False)

	if t>=(5*2):
		print("Reached maximum of steps")
		break

	# Wait for the next iteration
	rate.sleep()

print('out because ctrl + c. Data saved.')




